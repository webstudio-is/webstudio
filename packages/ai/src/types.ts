/**
 * Models types.
 *
 * Types for a generic vendor-agnostic LLM client.
 * Each vendor (eg. OpenAI) implementation must follow these types.
 */

export type ModelMessage = ["system" | "user" | "assistant", string];
export type ModelMessages = Array<ModelMessage>;

export type Model<ModelMessageFormat> = {
  // Turns ModelMessages into a model-specific messages format.
  generateMessages: ModelGenerateMessages<ModelMessageFormat>;
  // Regular request.
  request: ModelRequest<ModelMessageFormat>;
  // Streaming.
  requestStream: ModelRequestStream<ModelMessageFormat>;
};

export type ModelGenerateMessages<ModelMessage> = (
  messages: ModelMessages
) => ModelMessage[];

export type ModelRequestSuccess = {
  success: true;
  choices: string[];
  tokens: {
    prompt: number;
    completion: number;
  };
};

export type ModelRequest<ModelMessageFormat> = ({
  messages,
}: {
  messages: ReturnType<ModelGenerateMessages<ModelMessageFormat>>;
}) => Promise<ModelRequestSuccess | ErrorResponse>;

export type ModelRequestStream<ModelMessageFormat> = ({
  messages,
}: {
  messages: ReturnType<ModelGenerateMessages<ModelMessageFormat>>;
}) => Promise<StreamingTextResponse | ErrorResponse>;

/**
 * Chains types.
 *
 * A chain an async function that executes an arbitrarty number of steps, including calling a LLM.
 * Chain files are modules that export a createChain factory.
 * Each instance generated by the factory gets a reference to a model client (types below)
 * and a context object which includes input data such as prompt and other relevant methods for the chain.
 *
 * Additionally each chain should export types for Context and Response data (using these names) both as zod and TypeScript types.
 * zod types must have a Schema suffix. For example ResponseSchema.
 */

import type { StreamingTextResponse } from "ai";

/* Used on any kind of error response */
export type ErrorResponse = {
  success: false;
  type: "generic_error" | string;
  status: number;
  message: string;
};

export type SuccessResponse<ResponseData> = {
  success: true;
  data: ResponseData;
};

export type ChainResponseSuccess<ResponseData> = {
  success: true;
  tokens: number;
  data: ResponseData;
  llmMessages: ModelMessages[];
};

export type Chain<Model, Context, ResponseData> = (args: {
  model: Model;
  context: Context;
}) => Promise<ChainResponseSuccess<ResponseData> | ErrorResponse>;

export type ChainStream<Model, Context> = (request: {
  model: Model;
  context: Context;
}) => Promise<StreamingTextResponse | ErrorResponse>;
